/**
 * @jest-environment jsdom
 */

jest.mock('vscode', () => ({
    window: {
        withProgress: jest.fn().mockImplementation((...args: any[]) => {
            const fn = args[1];
            return Promise.resolve(fn({ report: jest.fn() }));
        }),
        showErrorMessage: jest.fn().mockImplementation(() => Promise.resolve('View Details'))
    },
    ProgressLocation: {
        Notification: 1
    }
}));

jest.mock('../../../../../src/utils/logger', () => ({
    EnhancedLogger: {
        getInstance: jest.fn().mockReturnValue({
            info: jest.fn(),
            error: jest.fn(),
            warn: jest.fn(),
            debug: jest.fn(),
            logOperation: jest.fn().mockImplementation((...args: any[]) => {
                const fn = args[2];
                return Promise.resolve(fn());
            })
        })
    }
}));

jest.mock('../../../../../src/workflow/build/monitoring/performance-tracker', () => ({
    PerformanceTracker: jest.fn().mockImplementation(() => ({
        initialize: jest.fn().mockImplementation(() => Promise.resolve()),
        startTracking: jest.fn().mockImplementation(() => Promise.resolve('test-session')),
        trackOperation: jest.fn().mockImplementation((...args: any[]) => {
            const fn = args[1];
            return Promise.resolve(fn());
        })
    }))
}));

import { describe, expect, test, beforeEach, jest } from '@jest/globals';
import { VulnerabilityScanner, VulnerabilityConfig, VulnerabilityResult } from '../../../../../src/workflow/production/security/vulnerability-scanner';
import { EnhancedLogger } from '../../../../../src/utils/logger';
import * as vscode from 'vscode';

describe('VulnerabilityScanner', () => {
    let scanner: VulnerabilityScanner;
    let mockLogger: jest.Mocked<EnhancedLogger>;
    let mockNetworkService: any;
    let testConfig: VulnerabilityConfig;
    const TEST_NETWORK_URL = 'http://127.0.0.1:8545';
    const TEST_CONTRACT_PATH = '/test/contracts/TestContract.sol';

    beforeEach(() => {
        jest.clearAllMocks();
        
        mockNetworkService = {
            connect: jest.fn().mockImplementation(() => Promise.resolve('connected')),
            validateConnection: jest.fn().mockImplementation(() => Promise.resolve(true))
        };

        testConfig = {
            scanDepth: 'deep',
            autoFix: true,
            thresholds: {
                critical: 85,
                high: 70,
                medium: 50
            },
            excludePatterns: [],
            reportFormat: 'detailed'
        };

        mockLogger = (EnhancedLogger.getInstance() as jest.Mocked<EnhancedLogger>);
        scanner = new VulnerabilityScanner(testConfig, TEST_NETWORK_URL, mockNetworkService);
    });

    test('initializes successfully', async () => {
        await scanner.initialize();
        expect(mockLogger.info).toHaveBeenCalledWith(
            'Vulnerability scanner initialized successfully'
        );
    });

    test('validates configuration during initialization', async () => {
        const invalidConfig: VulnerabilityConfig = {
            ...testConfig,
            thresholds: {
                critical: -1,
                high: 70,
                medium: 50
            }
        };

        const invalidScanner = new VulnerabilityScanner(
            invalidConfig,
            TEST_NETWORK_URL,
            mockNetworkService
        );

        await expect(invalidScanner.initialize())
            .rejects.toThrow('Invalid threshold values');
    });

    test('prevents scanning before initialization', async () => {
        await expect(scanner.scanContract(TEST_CONTRACT_PATH))
            .rejects.toThrow('Vulnerability scanner not initialized');
    });

    test('performs contract scan successfully', async () => {
        await scanner.initialize();
        const results = await scanner.scanContract(TEST_CONTRACT_PATH);
        
        expect(Array.isArray(results)).toBe(true);
        expect(mockLogger.info).toHaveBeenCalledWith(
            expect.stringContaining('Attempting to auto-fix issues')
        );
    });

    test('handles critical vulnerabilities correctly', async () => {
        await scanner.initialize();
        
        const criticalVulnerability: VulnerabilityResult = {
            id: 'VULN-001',
            severity: 'critical',
            type: 'reentrancy',
            description: 'Critical reentrancy vulnerability detected',
            location: {
                file: TEST_CONTRACT_PATH,
                line: 42
            },
            impact: 'High risk of fund loss',
            remediation: 'Implement reentrancy guard',
            metadata: {},
            timestamp: Date.now()
        };

        // Updated mock implementation
        (scanner as any).checkSecurityPatterns = jest.fn().mockImplementation(() => 
            Promise.resolve([criticalVulnerability])
        );

        await scanner.scanContract(TEST_CONTRACT_PATH);
        expect(vscode.window.showErrorMessage).toHaveBeenCalled();
    });


    test('manages scan results correctly', async () => {
        await scanner.initialize();
        const testResults: VulnerabilityResult[] = [{
            id: 'VULN-001',
            severity: 'high',
            type: 'access-control',
            description: 'Test vulnerability',
            location: {
                file: TEST_CONTRACT_PATH
            },
            impact: 'Test impact',
            remediation: 'Test remediation',
            metadata: {},
            timestamp: Date.now()
        }];
    
        // Updated mock implementation using mockImplementation
        (scanner as any).checkSecurityPatterns = jest.fn().mockImplementation(() => 
            Promise.resolve(testResults)
        );
    
        await scanner.scanContract(TEST_CONTRACT_PATH);
        expect(scanner.getResults(TEST_CONTRACT_PATH)).toHaveLength(1);
        
        scanner.clearResults(TEST_CONTRACT_PATH);
        expect(scanner.getResults(TEST_CONTRACT_PATH)).toHaveLength(0);
    });
    
    test('respects scan depth configuration', async () => {
        await scanner.initialize();
        const basicScanner = new VulnerabilityScanner(
            { ...testConfig, scanDepth: 'basic' },
            TEST_NETWORK_URL,
            mockNetworkService
        );
        await basicScanner.initialize();

        const deepAnalysisSpy = jest.spyOn(scanner as any, 'performDeepAnalysis');
        await scanner.scanContract(TEST_CONTRACT_PATH);
        
        expect(deepAnalysisSpy).toHaveBeenCalled();
    });


    test('handles scan failures gracefully', async () => {
        await scanner.initialize();
        
        // Updated mock implementation
        (scanner as any).analyzeSource = jest.fn().mockImplementation(() => 
            Promise.reject(new Error('Analysis failed'))
        );

        await expect(scanner.scanContract(TEST_CONTRACT_PATH))
            .rejects.toThrow('Vulnerability scan failed: Analysis failed');
        
        expect(mockLogger.error).toHaveBeenCalled();
    });


});


// npm run test -- tests/suite/workflow/production/security/vulnerability-scanner.test.ts